# Zenith: Turso Data Model

**Version**: 2026-02-08 (v2)
**Status**: Design Document
**Purpose**: Complete relational data model for project state, knowledge tracking, and audit trail

**Changes from v1**: Added `issues` table, switched to Turso-native ID generation (`hex(randomblob(4))`), added AgentFS workspace integration, noted `turso` crate (v0.3.2) as primary dependency with AgentFS from git as workspace layer.

**Changes from v2**: Switched from `turso` crate to `libsql` crate (v0.9.29). Spike 0.2 revealed `turso` 0.5.0-pre.8 lacks FTS5 support. `libsql` provides native FTS5, same Turso Cloud embedded replica support. Schema SQL is unchanged — `libsql` is a C SQLite fork and supports all FTS5 syntax natively.

---

## Table of Contents

1. [Overview](#1-overview)
2. [Project & Session Management](#2-project--session-management)
3. [Core Knowledge Entities](#3-core-knowledge-entities)
4. [Issues & Work Tracking](#4-issues--work-tracking)
5. [Compatibility Tracking](#5-compatibility-tracking)
6. [Universal Linking](#6-universal-linking)
7. [Audit Trail](#7-audit-trail)
8. [Full-Text Search (FTS5)](#8-full-text-search-fts5)
9. [Indexes](#9-indexes)
10. [FTS5 Sync Triggers](#10-fts5-sync-triggers)
11. [Entity Relationship Diagram](#11-entity-relationship-diagram)
12. [Sync Strategy](#12-sync-strategy)
13. [AgentFS Integration](#13-agentfs-integration)

---

## 1. Overview

Zenith uses **Turso/libSQL** as the relational source of truth for all project state. Turso provides:

- **Embedded replicas** for offline-first local operation
- **Cloud sync** triggered only at `zen wrap-up` to avoid conflicts and data corruption
- **FTS5** for full-text search across all knowledge entities
- **libsql_vector_idx** available if needed for local vector search

### Design Principles

- Every entity references the **session** it was created in
- Every mutation writes to the **audit trail** (append-only)
- **Entity links** provide universal many-to-many relationships between any entities
- **FTS5 virtual tables** with triggers keep search indexes in sync automatically
- **Tags are user-defined strings**, not enums -- the LLM and user decide what tags make sense
- **IDs are generated by Turso** using `hex(randomblob(4))` -- 8-char hex strings, prefixed in the app layer (e.g., `fnd-a3f8b2c1`). No external ID generation libraries needed
- **Issues** are a separate entity from research and tasks -- issues track bugs/features/requests, research tracks investigations, tasks track specific work items

### ID Generation

IDs are generated in SQL using Turso's built-in `randomblob()`:

```sql
-- Generate a prefixed ID in SQL
INSERT INTO findings (id, ...) 
VALUES ('fnd-' || lower(hex(randomblob(4))), ...);

-- Or generate just the random part and prefix in the app layer
SELECT lower(hex(randomblob(4)));  -- returns e.g., "a3f8b2c1"
```

| Entity | Prefix | Example |
|--------|--------|---------|
| Session | `ses-` | `ses-a3f8b2c1` |
| Research | `res-` | `res-c4e2d1f0` |
| Finding | `fnd-` | `fnd-b7a3f9e2` |
| Hypothesis | `hyp-` | `hyp-e1c4b2d3` |
| Insight | `ins-` | `ins-d2f5a8c1` |
| Issue | `iss-` | `iss-f3b7c1e4` |
| Task | `tsk-` | `tsk-a8d3e2b5` |
| Implementation Log | `imp-` | `imp-c1f4b7a9` |
| Compatibility Check | `cmp-` | `cmp-e5a2d9f3` |
| Entity Link | `lnk-` | `lnk-b3c8f1d6` |
| Audit Entry | `aud-` | `aud-d7e2a4c8` |

### Database Crate

Primary dependency: `libsql` crate (v0.9.29) from crates.io, which provides the `Builder` API for local, remote, and embedded replica databases. Supports native FTS5, Turso Cloud sync, and all standard SQLite features.

### Storage Location

```
.zenith/
  db/
    main.db            # Turso embedded replica (this schema)
```

---

## 2. Project & Session Management

### project_meta

Stores key-value pairs for project-level configuration detected at `zen init` or `zen onboard`.

```sql
CREATE TABLE project_meta (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

**Common keys:**

| Key | Example Value | Set By |
|-----|---------------|--------|
| `name` | `my-web-app` | `zen init` |
| `language` | `rust` | `zen init` (auto-detected) |
| `ecosystem` | `rust` | `zen init` (auto-detected) |
| `root_path` | `/home/user/projects/my-web-app` | `zen init` |
| `vcs` | `git` | `zen init` (auto-detected) |
| `initialized_at` | `2026-02-07T12:00:00Z` | `zen init` |
| `zenith_version` | `0.1.0` | `zen init` |

### project_dependencies

Detected from manifest files (`Cargo.toml`, `package.json`, `go.mod`, `mix.exs`, `pyproject.toml`). Tracks whether each dependency has been indexed in the DuckLake data lake.

```sql
CREATE TABLE project_dependencies (
    ecosystem TEXT NOT NULL,
    name TEXT NOT NULL,
    version TEXT,
    source TEXT NOT NULL,
    indexed BOOLEAN DEFAULT FALSE,
    indexed_at TEXT,
    PRIMARY KEY (ecosystem, name)
);
```

| Column | Description |
|--------|-------------|
| `ecosystem` | `rust`, `npm`, `hex`, `pypi`, `go` |
| `name` | Package name as it appears in the registry |
| `version` | Version constraint from manifest (e.g., `^1.0`, `>=0.5`) |
| `source` | Which manifest file: `cargo.toml`, `package.json`, `go.mod`, `mix.exs`, `pyproject.toml` |
| `indexed` | `TRUE` if the package has been cloned, parsed, and indexed in DuckLake |
| `indexed_at` | Timestamp of last indexing |

### sessions

Tracks work sessions. The LLM starts a session at the beginning of a conversation and wraps it up at the end.

```sql
CREATE TABLE sessions (
    id TEXT PRIMARY KEY,
    started_at TEXT NOT NULL DEFAULT (datetime('now')),
    ended_at TEXT,
    status TEXT NOT NULL DEFAULT 'active',
    summary TEXT
);
```

**Status transitions:**

```
active → wrapped_up    (normal wrap-up)
active → abandoned     (session ended without wrap-up)
```

| Column | Description |
|--------|-------------|
| `id` | Short hash ID (e.g., `ses-a3f8b2`) |
| `status` | `active`, `wrapped_up`, `abandoned` |
| `summary` | LLM-generated summary at wrap-up time. Describes what was accomplished, what's pending |

### session_snapshots

Point-in-time counts and summary generated at `zen wrap-up`. Enables fast `zen whats-next` without scanning the full database.

```sql
CREATE TABLE session_snapshots (
    session_id TEXT PRIMARY KEY REFERENCES sessions(id),
    open_tasks INTEGER NOT NULL DEFAULT 0,
    in_progress_tasks INTEGER NOT NULL DEFAULT 0,
    pending_hypotheses INTEGER NOT NULL DEFAULT 0,
    unverified_hypotheses INTEGER NOT NULL DEFAULT 0,
    recent_findings INTEGER NOT NULL DEFAULT 0,
    open_research INTEGER NOT NULL DEFAULT 0,
    summary TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

---

## 3. Core Knowledge Entities

### research_items

A research item is a question or investigation topic. "Does library X work with library Y?" or "Evaluate Rust HTTP client libraries."

```sql
CREATE TABLE research_items (
    id TEXT PRIMARY KEY,
    session_id TEXT REFERENCES sessions(id),
    title TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'open',
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

**Status transitions:**

```
open → in_progress → resolved
                   → abandoned
```

### findings

A discovered fact. Can be standalone (encountered during a spike) or linked to a research item. Tagged with user-defined labels.

```sql
CREATE TABLE findings (
    id TEXT PRIMARY KEY,
    research_id TEXT REFERENCES research_items(id),
    session_id TEXT REFERENCES sessions(id),
    content TEXT NOT NULL,
    source TEXT,
    confidence TEXT NOT NULL DEFAULT 'medium',
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

| Column | Description |
|--------|-------------|
| `research_id` | **Nullable**. Links to the research item that prompted this finding. Null for standalone findings |
| `source` | Where the finding came from: file path, URL, `manual`, `package:tokio:1.40` |
| `confidence` | `high`, `medium`, `low` |

### finding_tags

Many-to-many tags on findings. Tags are **user-defined strings** -- there is no fixed enum. The LLM and user create whatever tags make sense for their workflow.

```sql
CREATE TABLE finding_tags (
    finding_id TEXT NOT NULL REFERENCES findings(id),
    tag TEXT NOT NULL,
    PRIMARY KEY (finding_id, tag)
);
```

**Common tags (examples, not exhaustive):**

| Tag | Meaning |
|-----|---------|
| `deps-conflict` | Dependency version conflict discovered |
| `verified` | Finding has been confirmed |
| `needs-verification` | Finding needs validation |
| `might-need-spike` | Requires a proof-of-concept to validate |
| `require-api-keys` | Feature requires external API credentials |
| `breaking-change` | Involves a breaking API change |
| `performance-concern` | Potential performance issue |
| `security-risk` | Security-related concern |
| `deprecation-warning` | Uses deprecated API or pattern |

### hypotheses

Something believed to be true that needs validation. Status tracks the investigation lifecycle.

```sql
CREATE TABLE hypotheses (
    id TEXT PRIMARY KEY,
    research_id TEXT REFERENCES research_items(id),
    finding_id TEXT REFERENCES findings(id),
    session_id TEXT REFERENCES sessions(id),
    content TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'unverified',
    reason TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

**Status transitions:**

```
unverified → analyzing → confirmed
                       → debunked
                       → partially_confirmed
                       → inconclusive
```

| Status | Meaning |
|--------|---------|
| `unverified` | Initial state. Hypothesis stated but not yet investigated |
| `analyzing` | Actively being investigated |
| `confirmed` | Proven true |
| `debunked` | Proven false |
| `partially_confirmed` | Some aspects true, others not |
| `inconclusive` | Investigated but couldn't determine truth |

| Column | Description |
|--------|-------------|
| `finding_id` | **Nullable**. The finding that triggered this hypothesis |
| `reason` | Why the status changed. Set when transitioning from `analyzing` to a terminal state |

### insights

A conclusion drawn from multiple findings. Higher-level than a finding -- synthesizes information into actionable knowledge.

```sql
CREATE TABLE insights (
    id TEXT PRIMARY KEY,
    research_id TEXT REFERENCES research_items(id),
    session_id TEXT REFERENCES sessions(id),
    content TEXT NOT NULL,
    confidence TEXT NOT NULL DEFAULT 'medium',
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

**Example insight:** "Based on findings F1, F2, F3: `reqwest` is the best HTTP client for our use case because it supports async, has the largest community, and its API is compatible with our existing tower middleware stack."

Linked to its source findings via `entity_links`.

---

## 4. Issues & Work Tracking

### issues

Issues track bugs, features, requests, spikes, and epics. They are distinct from research items (investigations) and tasks (specific work items). An issue can spawn tasks, link to research, and reference findings.

```sql
CREATE TABLE issues (
    id TEXT PRIMARY KEY,
    type TEXT NOT NULL DEFAULT 'task',
    parent_id TEXT REFERENCES issues(id),
    title TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'open',
    priority INTEGER NOT NULL DEFAULT 3,
    session_id TEXT REFERENCES sessions(id),
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

| Column | Description |
|--------|-------------|
| `type` | `bug`, `feature`, `spike`, `epic`, `request` |
| `parent_id` | **Nullable**. For subtask/epic-child relationships. An epic can have child issues |
| `priority` | 1 (highest) to 5 (lowest) |
| `status` | `open`, `in_progress`, `done`, `blocked`, `abandoned` |

**Status transitions:**

```
open → in_progress → done
                   → blocked → in_progress (unblocked)
                   → abandoned
```

**Type semantics:**

| Type | When to use |
|------|-------------|
| `bug` | Something is broken or behaves incorrectly |
| `feature` | New functionality to implement |
| `spike` | Time-boxed investigation or proof-of-concept |
| `epic` | Large body of work containing child issues |
| `request` | User-facing request or change |

### tasks

Specific actionable work items. More granular than issues -- a single issue may spawn multiple tasks. Tasks can also be standalone.

```sql
CREATE TABLE tasks (
    id TEXT PRIMARY KEY,
    research_id TEXT REFERENCES research_items(id),
    issue_id TEXT REFERENCES issues(id),
    session_id TEXT REFERENCES sessions(id),
    title TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'open',
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

| Column | Description |
|--------|-------------|
| `issue_id` | **Nullable**. Links to the issue this task belongs to |
| `research_id` | **Nullable**. Links to the research item that spawned this task |

**Status transitions:**

```
open → in_progress → done
                   → blocked → in_progress (unblocked)
```

### implementation_log

Records where code was implemented, linked to the task that required it. Enables "what changed for task X?" queries and provides the LLM with precise file:line references.

```sql
CREATE TABLE implementation_log (
    id TEXT PRIMARY KEY,
    task_id TEXT REFERENCES tasks(id),
    session_id TEXT REFERENCES sessions(id),
    file_path TEXT NOT NULL,
    start_line INTEGER,
    end_line INTEGER,
    description TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

**Example:** Task `tsk-b2c4` required adding a retry mechanism. Implementation log entry:
- `file_path`: `src/http/client.rs`
- `start_line`: 45
- `end_line`: 82
- `description`: "Added exponential backoff retry with max 3 attempts"

---

## 5. Compatibility Tracking

### compatibility_checks

Tracks whether specific package combinations work together. Linked to the finding that determined the result.

```sql
CREATE TABLE compatibility_checks (
    id TEXT PRIMARY KEY,
    package_a TEXT NOT NULL,
    package_b TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'unknown',
    conditions TEXT,
    finding_id TEXT REFERENCES findings(id),
    session_id TEXT REFERENCES sessions(id),
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

| Column | Description |
|--------|-------------|
| `package_a`, `package_b` | Format: `ecosystem:name:version` (e.g., `rust:tokio:1.40.0`) |
| `status` | `compatible`, `incompatible`, `conditional`, `unknown` |
| `conditions` | Free text. E.g., "Only with `tokio` feature `full` enabled" |
| `finding_id` | The finding that established this compatibility result |

**Status meanings:**

| Status | Meaning |
|--------|---------|
| `compatible` | Works together without issues |
| `incompatible` | Cannot be used together |
| `conditional` | Works under specific conditions (documented in `conditions`) |
| `unknown` | Not yet tested |

---

## 6. Universal Linking

### entity_links

Many-to-many relationships between any two entities in the system. This is the glue that connects research, findings, hypotheses, tasks, insights, implementation, and compatibility checks.

```sql
CREATE TABLE entity_links (
    id TEXT PRIMARY KEY,
    source_type TEXT NOT NULL,
    source_id TEXT NOT NULL,
    target_type TEXT NOT NULL,
    target_id TEXT NOT NULL,
    relation TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(source_type, source_id, target_type, target_id, relation)
);
```

**Entity types:** `research`, `finding`, `hypothesis`, `task`, `issue`, `insight`, `impl_log`, `compatibility_check`, `session`

**Relation types:**

| Relation | Meaning | Example |
|----------|---------|---------|
| `blocks` | Source blocks target from proceeding | Task A blocks Task B |
| `validates` | Source validates target | Finding validates Hypothesis |
| `debunks` | Source disproves target | Finding debunks Hypothesis |
| `implements` | Source implements target | Implementation Log implements Task |
| `relates-to` | General association | Research relates-to Research |
| `derived-from` | Source was derived from target | Insight derived-from Finding |
| `triggers` | Source caused target to be created | Finding triggers Hypothesis |
| `supersedes` | Source replaces target | Finding supersedes Finding |
| `depends-on` | Source depends on target | Task depends-on Task |

---

## 7. Audit Trail

### audit_trail

Append-only chronological record of every mutation in the system. Also mirrored to JSONL files in git for version control.

```sql
CREATE TABLE audit_trail (
    id TEXT PRIMARY KEY,
    session_id TEXT REFERENCES sessions(id),
    entity_type TEXT NOT NULL,
    entity_id TEXT NOT NULL,
    action TEXT NOT NULL,
    detail TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

| Column | Description |
|--------|-------------|
| `entity_type` | Which table was affected |
| `entity_id` | ID of the affected row |
| `action` | What happened (see below) |
| `detail` | JSON blob with context: before/after values, metadata, reasoning |

**Actions:**

| Action | Description |
|--------|-------------|
| `created` | Entity was created |
| `updated` | Entity fields were modified |
| `status_changed` | Status field transitioned (detail includes `from` and `to`) |
| `linked` | Entity link was created |
| `unlinked` | Entity link was removed |
| `tagged` | Tag was added to a finding |
| `untagged` | Tag was removed from a finding |
| `indexed` | Package was indexed in the data lake |
| `session_start` | Session began |
| `session_end` | Session ended (wrap-up or abandon) |
| `wrap_up` | Wrap-up procedure completed |

**Example detail JSON:**

```json
{
    "from": "unverified",
    "to": "confirmed",
    "reason": "Spike validated that tokio 1.40 runtime is compatible with axum 0.8",
    "related_finding": "fnd-c4e2"
}
```

---

## 8. Full-Text Search (FTS5)

FTS5 virtual tables enable fast full-text search across all knowledge entities using porter stemming and unicode61 tokenization.

```sql
CREATE VIRTUAL TABLE findings_fts USING fts5(
    content, source,
    content='findings',
    content_rowid='rowid',
    tokenize='porter unicode61'
);

CREATE VIRTUAL TABLE hypotheses_fts USING fts5(
    content, reason,
    content='hypotheses',
    content_rowid='rowid',
    tokenize='porter unicode61'
);

CREATE VIRTUAL TABLE insights_fts USING fts5(
    content,
    content='insights',
    content_rowid='rowid',
    tokenize='porter unicode61'
);

CREATE VIRTUAL TABLE research_fts USING fts5(
    title, description,
    content='research_items',
    content_rowid='rowid',
    tokenize='porter unicode61'
);

CREATE VIRTUAL TABLE tasks_fts USING fts5(
    title, description,
    content='tasks',
    content_rowid='rowid',
    tokenize='porter unicode61'
);

CREATE VIRTUAL TABLE issues_fts USING fts5(
    title, description,
    content='issues',
    content_rowid='rowid',
    tokenize='porter unicode61'
);

CREATE VIRTUAL TABLE audit_fts USING fts5(
    action, detail,
    content='audit_trail',
    content_rowid='rowid',
    tokenize='porter unicode61'
);
```

**Usage example:**

```sql
-- Search findings for "async runtime compatibility"
SELECT f.id, f.content, f.confidence,
    snippet(findings_fts, 0, '>>>', '<<<', '...', 64) as snippet
FROM findings_fts
JOIN findings f ON f.rowid = findings_fts.rowid
WHERE findings_fts MATCH 'async runtime compatibility'
ORDER BY rank
LIMIT 10;
```

---

## 9. Indexes

```sql
-- Findings
CREATE INDEX idx_findings_research ON findings(research_id);
CREATE INDEX idx_findings_session ON findings(session_id);
CREATE INDEX idx_findings_confidence ON findings(confidence);
CREATE INDEX idx_finding_tags_tag ON finding_tags(tag);

-- Hypotheses
CREATE INDEX idx_hypotheses_research ON hypotheses(research_id);
CREATE INDEX idx_hypotheses_status ON hypotheses(status);
CREATE INDEX idx_hypotheses_session ON hypotheses(session_id);

-- Insights
CREATE INDEX idx_insights_research ON insights(research_id);
CREATE INDEX idx_insights_session ON insights(session_id);

-- Issues
CREATE INDEX idx_issues_type ON issues(type);
CREATE INDEX idx_issues_status ON issues(status);
CREATE INDEX idx_issues_parent ON issues(parent_id);
CREATE INDEX idx_issues_session ON issues(session_id);
CREATE INDEX idx_issues_priority ON issues(priority);

-- Tasks
CREATE INDEX idx_tasks_research ON tasks(research_id);
CREATE INDEX idx_tasks_issue ON tasks(issue_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_session ON tasks(session_id);

-- Implementation Log
CREATE INDEX idx_impl_log_task ON implementation_log(task_id);
CREATE INDEX idx_impl_log_file ON implementation_log(file_path);
CREATE INDEX idx_impl_log_session ON implementation_log(session_id);

-- Compatibility
CREATE INDEX idx_compat_packages ON compatibility_checks(package_a, package_b);
CREATE INDEX idx_compat_status ON compatibility_checks(status);

-- Entity Links
CREATE INDEX idx_entity_links_source ON entity_links(source_type, source_id);
CREATE INDEX idx_entity_links_target ON entity_links(target_type, target_id);
CREATE INDEX idx_entity_links_relation ON entity_links(relation);

-- Audit Trail
CREATE INDEX idx_audit_entity ON audit_trail(entity_type, entity_id);
CREATE INDEX idx_audit_session ON audit_trail(session_id);
CREATE INDEX idx_audit_action ON audit_trail(action);
CREATE INDEX idx_audit_created ON audit_trail(created_at);

-- Project
CREATE INDEX idx_project_deps_indexed ON project_dependencies(indexed);
CREATE INDEX idx_sessions_status ON sessions(status);
```

---

## 10. FTS5 Sync Triggers

Triggers keep FTS5 virtual tables in sync with their content tables on insert, update, and delete.

### findings

```sql
CREATE TRIGGER findings_ai AFTER INSERT ON findings BEGIN
    INSERT INTO findings_fts(rowid, content, source)
    VALUES (new.rowid, new.content, new.source);
END;

CREATE TRIGGER findings_ad AFTER DELETE ON findings BEGIN
    INSERT INTO findings_fts(findings_fts, rowid, content, source)
    VALUES ('delete', old.rowid, old.content, old.source);
END;

CREATE TRIGGER findings_au AFTER UPDATE ON findings BEGIN
    INSERT INTO findings_fts(findings_fts, rowid, content, source)
    VALUES ('delete', old.rowid, old.content, old.source);
    INSERT INTO findings_fts(rowid, content, source)
    VALUES (new.rowid, new.content, new.source);
END;
```

### hypotheses

```sql
CREATE TRIGGER hypotheses_ai AFTER INSERT ON hypotheses BEGIN
    INSERT INTO hypotheses_fts(rowid, content, reason)
    VALUES (new.rowid, new.content, new.reason);
END;

CREATE TRIGGER hypotheses_ad AFTER DELETE ON hypotheses BEGIN
    INSERT INTO hypotheses_fts(hypotheses_fts, rowid, content, reason)
    VALUES ('delete', old.rowid, old.content, old.reason);
END;

CREATE TRIGGER hypotheses_au AFTER UPDATE ON hypotheses BEGIN
    INSERT INTO hypotheses_fts(hypotheses_fts, rowid, content, reason)
    VALUES ('delete', old.rowid, old.content, old.reason);
    INSERT INTO hypotheses_fts(rowid, content, reason)
    VALUES (new.rowid, new.content, new.reason);
END;
```

### insights

```sql
CREATE TRIGGER insights_ai AFTER INSERT ON insights BEGIN
    INSERT INTO insights_fts(rowid, content)
    VALUES (new.rowid, new.content);
END;

CREATE TRIGGER insights_ad AFTER DELETE ON insights BEGIN
    INSERT INTO insights_fts(insights_fts, rowid, content)
    VALUES ('delete', old.rowid, old.content);
END;

CREATE TRIGGER insights_au AFTER UPDATE ON insights BEGIN
    INSERT INTO insights_fts(insights_fts, rowid, content)
    VALUES ('delete', old.rowid, old.content);
    INSERT INTO insights_fts(rowid, content)
    VALUES (new.rowid, new.content);
END;
```

### research_items

```sql
CREATE TRIGGER research_ai AFTER INSERT ON research_items BEGIN
    INSERT INTO research_fts(rowid, title, description)
    VALUES (new.rowid, new.title, new.description);
END;

CREATE TRIGGER research_ad AFTER DELETE ON research_items BEGIN
    INSERT INTO research_fts(research_fts, rowid, title, description)
    VALUES ('delete', old.rowid, old.title, old.description);
END;

CREATE TRIGGER research_au AFTER UPDATE ON research_items BEGIN
    INSERT INTO research_fts(research_fts, rowid, title, description)
    VALUES ('delete', old.rowid, old.title, old.description);
    INSERT INTO research_fts(rowid, title, description)
    VALUES (new.rowid, new.title, new.description);
END;
```

### tasks

```sql
CREATE TRIGGER tasks_ai AFTER INSERT ON tasks BEGIN
    INSERT INTO tasks_fts(rowid, title, description)
    VALUES (new.rowid, new.title, new.description);
END;

CREATE TRIGGER tasks_ad AFTER DELETE ON tasks BEGIN
    INSERT INTO tasks_fts(tasks_fts, rowid, title, description)
    VALUES ('delete', old.rowid, old.title, old.description);
END;

CREATE TRIGGER tasks_au AFTER UPDATE ON tasks BEGIN
    INSERT INTO tasks_fts(tasks_fts, rowid, title, description)
    VALUES ('delete', old.rowid, old.title, old.description);
    INSERT INTO tasks_fts(rowid, title, description)
    VALUES (new.rowid, new.title, new.description);
END;
```

### issues

```sql
CREATE TRIGGER issues_ai AFTER INSERT ON issues BEGIN
    INSERT INTO issues_fts(rowid, title, description)
    VALUES (new.rowid, new.title, new.description);
END;

CREATE TRIGGER issues_ad AFTER DELETE ON issues BEGIN
    INSERT INTO issues_fts(issues_fts, rowid, title, description)
    VALUES ('delete', old.rowid, old.title, old.description);
END;

CREATE TRIGGER issues_au AFTER UPDATE ON issues BEGIN
    INSERT INTO issues_fts(issues_fts, rowid, title, description)
    VALUES ('delete', old.rowid, old.title, old.description);
    INSERT INTO issues_fts(rowid, title, description)
    VALUES (new.rowid, new.title, new.description);
END;
```

### audit_trail

```sql
CREATE TRIGGER audit_ai AFTER INSERT ON audit_trail BEGIN
    INSERT INTO audit_fts(rowid, action, detail)
    VALUES (new.rowid, new.action, new.detail);
END;
```

Note: audit trail is append-only -- no update or delete triggers needed.

---

## 11. Entity Relationship Diagram

```
                         ┌──────────────┐
                         │   sessions   │
                         │              │
                         │ id           │
                         │ status       │
                         │ summary      │
                         └──────┬───────┘
                                │ 1:1
                         ┌──────▼───────────┐
                         │ session_snapshots │
                         └──────────────────┘

     ┌───────────────────────┼──────────────────────────┐
     │                       │                          │
┌────▼─────────┐     ┌──────▼───────┐          ┌───────▼──────┐
│research_items│     │   findings   │          │    issues    │
│              │◄────│              │          │              │
│ id           │     │ id           │          │ id           │
│ title        │     │ research_id  │          │ type         │
│ status       │     │ content      │          │ parent_id ──►│ (self-ref)
└──────┬───────┘     │ confidence   │          │ title        │
       │             └──┬───┬───────┘          │ status       │
       │                │   │                  │ priority     │
       │         ┌──────▼┐  │                  └───────┬──────┘
       │         │finding│  │                          │
       │         │_tags  │  │                   ┌──────▼───────┐
       │         └───────┘  │                   │    tasks     │
       │                    │                   │              │
       │              ┌─────▼──────┐            │ issue_id     │
       │              │  insights  │            │ research_id  │
       │              │            │            │ title        │
       │              │ research_id│            │ status       │
       │              │ confidence │            └──────┬───────┘
       │              └────────────┘                   │
       │                                        ┌──────▼──────────┐
┌──────▼───────┐                                │implementation_log│
│  hypotheses  │                                │                  │
│              │                                │ task_id          │
│ finding_id   │                                │ file_path        │
│ status       │                                │ start_line       │
│ reason       │                                │ end_line         │
└──────────────┘                                └──────────────────┘
       │
┌──────▼──────────────┐
│compatibility_checks │
│                     │
│ package_a           │
│ package_b           │
│ status              │
│ finding_id          │
└─────────────────────┘

┌─────────────────────────────────────────┐
│            entity_links                  │
│                                          │
│ source_type + source_id ──► any entity   │
│ target_type + target_id ──► any entity   │
│ relation                                 │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│            audit_trail                   │
│            (append-only)                 │
│                                          │
│ entity_type + entity_id ──► any entity   │
│ action, detail (JSON)                    │
└─────────────────────────────────────────┘
```

---

## 12. Sync Strategy

### Local-First Operation

Zenith operates on an **embedded Turso replica** (`main.db`). All reads and writes go to the local database with zero network latency.

### Sync on Wrap-Up Only

Cloud sync happens **exclusively** during `zen wrap-up`:

```
zen wrap-up
  1. Generate session summary
  2. Create session snapshot
  3. Mark session as wrapped_up
  4. Export audit trail to JSONL (git)
  5. Sync embedded replica to Turso cloud   ← only sync point
  6. Optionally auto-commit
```

This avoids:
- **Conflicts** from concurrent writes
- **Data corruption** from partial syncs
- **Network dependency** during active work

### Recovery

If a session is abandoned (crash, force quit), the next `zen init` or `zen session start` detects the orphaned active session, marks it as `abandoned`, and creates a new one.

---

## 13. AgentFS Integration

### Role Separation

Zenith uses **two storage layers** that complement each other:

| Concern | Store | Why |
|---------|-------|-----|
| Knowledge state (findings, hypotheses, tasks, issues, audit) | Turso (this schema) | Relational, query-heavy, FTS5, entity linking |
| File operations (cloning, scanning, workspace isolation) | AgentFS | CoW efficiency, file-level audit, workspace snapshots |

### Where AgentFS Is Used

**1. Package Indexing (`zen install`)**

Each `zen install` creates an AgentFS workspace for the clone → parse → index pipeline:

```
create workspace "index-tokio-1.40.0"
  → git clone --depth 1 into workspace
  → tree-sitter parse source files
  → fastembed generate vectors
  → write to DuckLake
  → delete workspace
```

Benefits: crash-safe (no orphaned temp files), parallel installs in isolated workspaces, CoW-efficient for re-indexing new versions.

**2. Session Workspaces**

Each `zen session start` creates an AgentFS workspace:

```
create workspace "ses-a3f8b2c1"
  → all file reads during the session are logged by AgentFS audit
  → at wrap-up: snapshot workspace, sync to cloud
```

Benefits: automatic file-level audit per session, clean separation from other sessions.

**3. File-Level Audit**

AgentFS audit log tracks every file operation. Exposed via `zen audit --files`:

```bash
zen audit --files --limit 10   # File operations (AgentFS)
zen audit --limit 10           # Knowledge operations (Turso)
zen audit --all --limit 10     # Combined
```

### AgentFS Dependency

Primary: `agentfs` from git (`github.com/tursodatabase/agentfs`, `sdk/rust` path). AgentFS is BETA but actively developed by the Turso team.

```toml
[dependencies]
agentfs = { git = "https://github.com/tursodatabase/agentfs", path = "sdk/rust" }
```

**Fallback plan**: If AgentFS from git doesn't compile or is too unstable, we build a minimal workspace abstraction on top of `tempfile::TempDir`. The workspace interface is behind a trait, so swapping implementations is transparent to the rest of the system.

### What AgentFS Does NOT Replace

- Our Turso schema (this document) -- knowledge state remains in our own tables
- DuckDB/DuckLake -- documentation lake with vector search
- FTS5 on our entities -- structured search over knowledge
- JSONL audit trail in git -- version-controlled history

---

## Cross-References

- DuckLake data model: [02-ducklake-data-model.md](./02-ducklake-data-model.md)
- Architecture overview: [03-architecture-overview.md](./03-architecture-overview.md)
- CLI API design: [04-cli-api-design.md](./04-cli-api-design.md)
- Crate designs: [05-crate-designs.md](./05-crate-designs.md)
