use std::fs;
use std::path::{Path, PathBuf};

use crate::error::HookError;

const PRE_COMMIT_SCRIPT: &str = r#"#!/bin/bash
# Zenith pre-commit hook (generated by znt)
if command -v znt >/dev/null 2>&1; then
    exec znt hook pre-commit "$@"
else
    echo "zenith: 'znt' not in PATH - skipping JSONL validation" >&2
    echo "zenith: install with: cargo install --path crates/zen-cli" >&2
    exit 0
fi
"#;

const POST_CHECKOUT_SCRIPT: &str = r#"#!/bin/bash
# Zenith post-checkout hook (generated by znt)
if command -v znt >/dev/null 2>&1; then
    exec znt hook post-checkout "$@"
else
    echo "zenith: 'znt' not in PATH - skipping checkout sync" >&2
    exit 0
fi
"#;

const POST_MERGE_SCRIPT: &str = r#"#!/bin/bash
# Zenith post-merge hook (generated by znt)
if command -v znt >/dev/null 2>&1; then
    exec znt hook post-merge "$@"
else
    echo "zenith: 'znt' not in PATH - skipping merge sync" >&2
    exit 0
fi
"#;

pub fn write_default_scripts(hooks_dir: &Path) -> Result<Vec<PathBuf>, HookError> {
    fs::create_dir_all(hooks_dir)?;

    let scripts = [
        ("pre-commit", PRE_COMMIT_SCRIPT),
        ("post-checkout", POST_CHECKOUT_SCRIPT),
        ("post-merge", POST_MERGE_SCRIPT),
    ];

    let mut written = Vec::new();
    for (name, content) in scripts {
        let path = hooks_dir.join(name);
        fs::write(&path, content)?;
        set_executable(&path)?;
        written.push(path);
    }
    Ok(written)
}

#[cfg(unix)]
fn set_executable(path: &Path) -> Result<(), HookError> {
    use std::os::unix::fs::PermissionsExt;
    let mut perms = fs::metadata(path)?.permissions();
    perms.set_mode(0o755);
    fs::set_permissions(path, perms)?;
    Ok(())
}

#[cfg(not(unix))]
fn set_executable(_path: &Path) -> Result<(), HookError> {
    Ok(())
}
