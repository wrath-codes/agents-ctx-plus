//! ID prefix constants and formatting helpers.
//!
//! Zenith IDs are generated by libSQL using `hex(randomblob(4))`, producing
//! 8-character hex strings. The Rust layer adds a type prefix: `"fnd-a3f8b2c1"`.
//!
//! This module provides:
//! - Prefix constants for all 12 entity types
//! - `format_id()` to combine a prefix with a random part
//! - `gen_id_sql()` to produce a SQL expression for use inside `INSERT` statements

/// Session prefix.
pub const PREFIX_SESSION: &str = "ses";

/// Research item prefix.
pub const PREFIX_RESEARCH: &str = "res";

/// Finding prefix.
pub const PREFIX_FINDING: &str = "fnd";

/// Hypothesis prefix.
pub const PREFIX_HYPOTHESIS: &str = "hyp";

/// Insight prefix.
pub const PREFIX_INSIGHT: &str = "ins";

/// Issue prefix.
pub const PREFIX_ISSUE: &str = "iss";

/// Task prefix.
pub const PREFIX_TASK: &str = "tsk";

/// Implementation log prefix.
pub const PREFIX_IMPL_LOG: &str = "imp";

/// Compatibility check prefix.
pub const PREFIX_COMPAT: &str = "cmp";

/// Study prefix.
pub const PREFIX_STUDY: &str = "stu";

/// Entity link prefix.
pub const PREFIX_LINK: &str = "lnk";

/// Audit entry prefix.
pub const PREFIX_AUDIT: &str = "aud";

/// All known prefixes, for validation.
pub const ALL_PREFIXES: &[&str] = &[
    PREFIX_SESSION,
    PREFIX_RESEARCH,
    PREFIX_FINDING,
    PREFIX_HYPOTHESIS,
    PREFIX_INSIGHT,
    PREFIX_ISSUE,
    PREFIX_TASK,
    PREFIX_IMPL_LOG,
    PREFIX_COMPAT,
    PREFIX_STUDY,
    PREFIX_LINK,
    PREFIX_AUDIT,
];

/// Format a prefixed ID from its prefix and random hex part.
///
/// Called after the database generates the random part via `hex(randomblob(4))`.
///
/// # Examples
///
/// ```
/// use zen_core::ids::format_id;
/// assert_eq!(format_id("fnd", "a3f8b2c1"), "fnd-a3f8b2c1");
/// ```
#[must_use]
pub fn format_id(prefix: &str, random: &str) -> String {
    format!("{prefix}-{random}")
}

/// Produce a SQL expression that generates a prefixed ID inside an INSERT.
///
/// The returned string is a SQL fragment, not a complete statement.
///
/// # Examples
///
/// ```
/// use zen_core::ids::gen_id_sql;
/// let sql = gen_id_sql("fnd");
/// assert_eq!(sql, "'fnd-' || lower(hex(randomblob(4)))");
/// ```
#[must_use]
pub fn gen_id_sql(prefix: &str) -> String {
    format!("'{prefix}-' || lower(hex(randomblob(4)))")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn format_id_produces_correct_output() {
        assert_eq!(format_id("ses", "a3f8b2c1"), "ses-a3f8b2c1");
        assert_eq!(format_id("fnd", "deadbeef"), "fnd-deadbeef");
        assert_eq!(format_id("aud", "00000000"), "aud-00000000");
    }

    #[test]
    fn gen_id_sql_produces_correct_expression() {
        let sql = gen_id_sql("fnd");
        assert_eq!(sql, "'fnd-' || lower(hex(randomblob(4)))");
    }

    #[test]
    fn gen_id_sql_for_all_prefixes() {
        for prefix in ALL_PREFIXES {
            let sql = gen_id_sql(prefix);
            assert!(sql.starts_with(&format!("'{prefix}-'")));
            assert!(sql.contains("randomblob"));
        }
    }

    #[test]
    fn all_prefixes_are_three_chars() {
        for prefix in ALL_PREFIXES {
            assert_eq!(prefix.len(), 3, "prefix '{prefix}' should be 3 chars");
        }
    }

    #[test]
    fn all_prefixes_are_unique() {
        let mut seen = std::collections::HashSet::new();
        for prefix in ALL_PREFIXES {
            assert!(seen.insert(prefix), "duplicate prefix: {prefix}");
        }
    }

    #[test]
    fn all_prefixes_count() {
        assert_eq!(ALL_PREFIXES.len(), 12);
    }
}
