# I/O

## Overview

Tokio provides async versions of `std::io::Read` and `std::io::Write` via the `AsyncRead` and `AsyncWrite` traits. These are not used directly — instead, use the extension traits `AsyncReadExt` and `AsyncWriteExt` which provide convenient async methods.

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
```

## Reading

### `read()`

Reads data into a buffer, returns the number of bytes read. `Ok(0)` signals EOF (the remote closed the connection).

```rust
use tokio::fs::File;
use tokio::io::AsyncReadExt;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut f = File::open("foo.txt").await?;
    let mut buf = [0u8; 1024];

    let n = f.read(&mut buf).await?;
    println!("Read {} bytes: {:?}", n, &buf[..n]);

    Ok(())
}
```

### `read_to_end()`

Reads all bytes until EOF into a `Vec<u8>`.

```rust
use tokio::fs::File;
use tokio::io::AsyncReadExt;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut f = File::open("foo.txt").await?;
    let mut buf = Vec::new();

    f.read_to_end(&mut buf).await?;
    println!("Read {} bytes total", buf.len());

    Ok(())
}
```

## Writing

### `write()`

Writes bytes from a buffer. Returns the number of bytes written, which **may be less** than the buffer length (partial write).

```rust
use tokio::io::AsyncWriteExt;
use tokio::fs::File;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut f = File::create("foo.txt").await?;
    let n = f.write(b"some bytes").await?;
    println!("Wrote {} bytes", n);

    Ok(())
}
```

### `write_all()`

Writes the **entire** buffer, retrying partial writes internally.

```rust
use tokio::io::AsyncWriteExt;
use tokio::fs::File;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut f = File::create("foo.txt").await?;
    f.write_all(b"some bytes").await?;

    Ok(())
}
```

## Helper Functions

```rust
use tokio::io;

// Copy all bytes from reader to writer
io::copy(&mut reader, &mut writer).await?;

// Standard streams
let mut stdin = io::stdin();
let mut stdout = io::stdout();
let mut stderr = io::stderr();
```

## Echo Server

### Using `io::copy()`

The simplest approach. Must split the socket because `io::copy()` needs separate reader and writer references.

```rust
use tokio::io;
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:6142").await?;

    loop {
        let (mut socket, _) = listener.accept().await?;

        tokio::spawn(async move {
            let (mut rd, mut wr) = socket.split();

            if io::copy(&mut rd, &mut wr).await.is_err() {
                eprintln!("failed to copy");
            }
        });
    }
}
```

### Manual Read/Write Loop

More control, handles EOF explicitly.

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:6142").await?;

    loop {
        let (mut socket, _) = listener.accept().await?;

        tokio::spawn(async move {
            let mut buf = vec![0u8; 1024];

            loop {
                match socket.read(&mut buf).await {
                    // EOF — remote closed
                    Ok(0) => return,
                    Ok(n) => {
                        if socket.write_all(&buf[..n]).await.is_err() {
                            return;
                        }
                    }
                    Err(_) => return,
                }
            }
        });
    }
}
```

## Splitting Reader and Writer

Three ways to get separate read/write halves from a `TcpStream`:

### `io::split()` — Generic

Works for any type implementing `AsyncRead + AsyncWrite`. Uses `Arc` + `Mutex` internally.

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;

let stream: TcpStream = TcpStream::connect("127.0.0.1:6142").await?;
let (mut rd, mut wr) = io::split(stream);
```

### `TcpStream::split()` — Zero-Cost, Same Task

Returns borrowed halves. No overhead, but both halves must stay in the **same task** (cannot be moved to `tokio::spawn`).

```rust
let (mut rd, mut wr) = socket.split();

// Both rd and wr borrow socket — same task only
io::copy(&mut rd, &mut wr).await?;
```

### `TcpStream::into_split()` — Owned, Cross-Task

Returns owned halves backed by `Arc`. Can be moved to different tasks.

```rust
let (mut rd, mut wr) = socket.into_split();

let write_task = tokio::spawn(async move {
    wr.write_all(b"hello").await.unwrap();
});

let read_task = tokio::spawn(async move {
    let mut buf = vec![0u8; 128];
    rd.read(&mut buf).await.unwrap();
});
```

## Buffer Allocation

| Approach | Pros | Cons |
|----------|------|------|
| Stack array `[0u8; 1024]` | No allocation, fast | Fixed size, lives on stack |
| `vec![0u8; 4096]` | Flexible size, heap allocated | Allocation cost per connection |

For long-lived connections, allocate the buffer once outside the loop and reuse it.

## EOF Handling

`Ok(0)` from `read()` means the peer closed the connection. **You must break from the loop** — this is a common bug source.

```rust
loop {
    match socket.read(&mut buf).await {
        Ok(0) => {
            // Peer closed — MUST break or return
            println!("connection closed");
            break;
        }
        Ok(n) => {
            // Process buf[..n]
        }
        Err(e) => {
            eprintln!("read error: {}", e);
            break;
        }
    }
}
```

Failing to handle `Ok(0)` results in an infinite busy loop consuming 100% CPU.

## See Also

- [Framing](./06-framing.md) — building higher-level protocols on top of raw I/O
- [Select](./07-select.md) — combining I/O with other async operations
