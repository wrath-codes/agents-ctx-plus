# I/O Traits and Utilities

Tokio provides async versions of the standard library's I/O traits, along with extension traits that add convenient async methods. These traits are the foundation for all async I/O in Tokio — networking, files, pipes, and in-memory buffers all implement them.

The core traits (`AsyncRead`, `AsyncWrite`, `AsyncBufRead`, `AsyncSeek`) define poll-based interfaces. The extension traits (`AsyncReadExt`, `AsyncWriteExt`, etc.) layer ergonomic `async fn` methods on top. You almost always work with the extension traits in application code.

---

## API Reference

### Core Traits

```rust
pub trait AsyncRead {
    fn poll_read(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &mut ReadBuf<'_>,
    ) -> Poll<io::Result<()>>;
}

pub trait AsyncWrite {
    fn poll_write(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &[u8],
    ) -> Poll<io::Result<usize>>;
    fn poll_flush(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<io::Result<()>>;
    fn poll_shutdown(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<io::Result<()>>;
}

pub trait AsyncBufRead: AsyncRead {
    fn poll_fill_buf(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<io::Result<&[u8]>>;
    fn consume(self: Pin<&mut Self>, amt: usize);
}

pub trait AsyncSeek {
    fn start_seek(self: Pin<&mut Self>, position: SeekFrom) -> io::Result<()>;
    fn poll_complete(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<io::Result<u64>>;
}
```

### Extension Trait Methods (AsyncReadExt)

```rust
pub trait AsyncReadExt: AsyncRead {
    async fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>;
    async fn read_buf<B: BufMut>(&mut self, buf: &mut B) -> io::Result<usize>;
    async fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()>;
    async fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize>;
    async fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize>;
    async fn read_u8(&mut self) -> io::Result<u8>;
    async fn read_u16(&mut self) -> io::Result<u16>;
    async fn read_u32(&mut self) -> io::Result<u32>;
    async fn read_u64(&mut self) -> io::Result<u64>;
    async fn read_u128(&mut self) -> io::Result<u128>;
    async fn read_i8(&mut self) -> io::Result<i8>;
    async fn read_i16(&mut self) -> io::Result<i16>;
    async fn read_i32(&mut self) -> io::Result<i32>;
    async fn read_i64(&mut self) -> io::Result<i64>;
    async fn read_i128(&mut self) -> io::Result<i128>;
    async fn read_f32(&mut self) -> io::Result<f32>;
    async fn read_f64(&mut self) -> io::Result<f64>;
    fn take(self, limit: u64) -> Take<Self>;
    fn chain<R: AsyncRead>(self, next: R) -> Chain<Self, R>;
}
```

### Extension Trait Methods (AsyncWriteExt)

```rust
pub trait AsyncWriteExt: AsyncWrite {
    async fn write(&mut self, buf: &[u8]) -> io::Result<usize>;
    async fn write_all(&mut self, buf: &[u8]) -> io::Result<()>;
    async fn write_buf<B: Buf>(&mut self, buf: &mut B) -> io::Result<usize>;
    async fn write_all_buf<B: Buf>(&mut self, buf: &mut B) -> io::Result<()>;
    async fn write_u8(&mut self, n: u8) -> io::Result<()>;
    async fn write_u16(&mut self, n: u16) -> io::Result<()>;
    async fn write_u32(&mut self, n: u32) -> io::Result<()>;
    async fn write_u64(&mut self, n: u64) -> io::Result<()>;
    async fn write_u128(&mut self, n: u128) -> io::Result<()>;
    async fn write_i8(&mut self, n: i8) -> io::Result<()>;
    async fn write_i16(&mut self, n: i16) -> io::Result<()>;
    async fn write_i32(&mut self, n: i32) -> io::Result<()>;
    async fn write_i64(&mut self, n: i64) -> io::Result<()>;
    async fn write_i128(&mut self, n: i128) -> io::Result<()>;
    async fn write_f32(&mut self, n: f32) -> io::Result<()>;
    async fn write_f64(&mut self, n: f64) -> io::Result<()>;
    async fn flush(&mut self) -> io::Result<()>;
    async fn shutdown(&mut self) -> io::Result<()>;
}
```

### Extension Trait Methods (AsyncBufReadExt)

```rust
pub trait AsyncBufReadExt: AsyncBufRead {
    async fn read_line(&mut self, buf: &mut String) -> io::Result<usize>;
    async fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize>;
    fn lines(self) -> Lines<Self>;
    fn split(self, byte: u8) -> Split<Self>;
    async fn fill_buf(&mut self) -> io::Result<&[u8]>;
}
```

### Extension Trait Methods (AsyncSeekExt)

```rust
pub trait AsyncSeekExt: AsyncSeek {
    async fn seek(&mut self, pos: SeekFrom) -> io::Result<u64>;
    async fn rewind(&mut self) -> io::Result<()>;
    async fn stream_position(&mut self) -> io::Result<u64>;
}
```

### Helper Functions

```rust
pub async fn copy<R, W>(reader: &mut R, writer: &mut W) -> io::Result<u64>
where
    R: AsyncRead + Unpin + ?Sized,
    W: AsyncWrite + Unpin + ?Sized;

pub async fn copy_bidirectional<A, B>(a: &mut A, b: &mut B) -> io::Result<(u64, u64)>
where
    A: AsyncRead + AsyncWrite + Unpin + ?Sized,
    B: AsyncRead + AsyncWrite + Unpin + ?Sized;

pub fn split<T>(io: T) -> (ReadHalf<T>, WriteHalf<T>)
where
    T: AsyncRead + AsyncWrite;

pub fn join<R, W>(read: R, write: W) -> Join<R, W>
where
    R: AsyncRead,
    W: AsyncWrite;

pub fn duplex(max_buf_size: usize) -> (DuplexStream, DuplexStream)

pub fn empty() -> Empty
pub fn sink() -> Sink
pub fn repeat(byte: u8) -> Repeat
```

### Buffered Wrappers

```rust
impl<R: AsyncRead> BufReader<R> {
    pub fn new(inner: R) -> Self
    pub fn with_capacity(capacity: usize, inner: R) -> Self
    pub fn get_ref(&self) -> &R
    pub fn get_mut(&mut self) -> &mut R
    pub fn into_inner(self) -> R
    pub fn buffer(&self) -> &[u8]
}

impl<W: AsyncWrite> BufWriter<W> {
    pub fn new(inner: W) -> Self
    pub fn with_capacity(capacity: usize, inner: W) -> Self
    pub fn get_ref(&self) -> &W
    pub fn get_mut(&mut self) -> &mut W
    pub fn into_inner(self) -> W
    pub fn buffer(&self) -> &[u8]
}

impl<RW: AsyncRead + AsyncWrite> BufStream<RW> {
    pub fn new(stream: RW) -> Self
    pub fn with_capacity(read_cap: usize, write_cap: usize, stream: RW) -> Self
}
```

---

## Core Traits

### `AsyncRead`

The async equivalent of `std::io::Read`. Implementors define `poll_read`, which reads bytes into a `ReadBuf` and returns `Poll::Ready(Ok(()))` when data is available, or `Poll::Pending` when the operation would block.

You rarely call `poll_read` directly. Instead, use the `AsyncReadExt` methods like `read()`, `read_to_end()`, and `read_exact()`.

### `AsyncWrite`

The async equivalent of `std::io::Write`. Implementors define three poll methods:

- `poll_write` — writes bytes from a buffer, returns the number of bytes written.
- `poll_flush` — flushes buffered data to the underlying I/O resource.
- `poll_shutdown` — shuts down the write half of the I/O resource (e.g., TCP FIN).

### `AsyncBufRead`

The async equivalent of `std::io::BufRead`. Extends `AsyncRead` with buffered access:

- `poll_fill_buf` — returns a reference to the internal buffer, filling it from the underlying reader if empty.
- `consume(amt)` — marks `amt` bytes as consumed from the internal buffer.

Wrap any `AsyncRead` in a `BufReader` to get `AsyncBufRead`.

### `AsyncSeek`

The async equivalent of `std::io::Seek`. Enables seeking to arbitrary positions within a stream. Used primarily with file I/O.

---

## AsyncReadExt Methods

### `read(buf)`

Reads some bytes into `buf`, returning the number of bytes read. Returns `0` at end-of-stream. May read fewer bytes than the buffer size — this is normal.

### `read_buf(buf)`

Reads into a `BufMut` (from the `bytes` crate), automatically advancing the cursor. More ergonomic than `read()` when working with `BytesMut`.

### `read_exact(buf)`

Reads exactly `buf.len()` bytes. Returns an error if end-of-stream is reached before the buffer is full. Use when you know the exact size of the data.

### `read_to_end(buf)`

Reads all bytes until end-of-stream, appending them to `buf`. Returns the total number of bytes read. Useful for reading an entire file or response body.

### `read_to_string(buf)`

Like `read_to_end` but appends to a `String`. Returns an error if the data is not valid UTF-8.

### `read_u8()` / `read_u16()` / `read_u32()` / `read_u64()`

Reads a single integer value in big-endian byte order. Use `read_u16_le()` etc. for little-endian. These are convenient for binary protocols.

### `take(limit)`

Wraps the reader with a byte limit. The returned `Take` adapter reads at most `limit` bytes. Useful for capping reads from untrusted sources.

### `chain(next)`

Chains two readers. When the first reader reaches end-of-stream, reads continue from `next`. Useful for prepending headers to a body.

---

## AsyncWriteExt Methods

### `write(buf)`

Writes some bytes from `buf`, returning the number of bytes written. May write fewer bytes than `buf.len()` — call in a loop or use `write_all()`.

### `write_all(buf)`

Writes the entire buffer, retrying as needed. Returns `Ok(())` when all bytes have been written, or an error if one occurs.

### `write_buf(buf)` / `write_all_buf(buf)`

Writes from a `Buf` (from the `bytes` crate), automatically advancing the cursor. `write_all_buf` writes the entire buffer.

### `write_u8(n)` / `write_u16(n)` / `write_u32(n)` / `write_u64(n)`

Writes a single integer value in big-endian byte order. Use `write_u16_le()` etc. for little-endian.

### `flush()`

Flushes buffered data to the underlying I/O resource. Returns when all buffered data has been written.

### `shutdown()`

Shuts down the write half of the I/O resource. For TCP, this sends a FIN packet. After shutdown, no more writes are possible.

---

## AsyncBufReadExt Methods

### `read_line(buf)`

Reads bytes until a newline (`\n`) is found, appending them (including the newline) to `buf`. Returns the number of bytes read, or `0` at end-of-stream.

### `read_until(byte, buf)`

Reads bytes until the specified delimiter byte is found, appending them (including the delimiter) to `buf`.

### `lines()`

Returns a `Lines` stream that yields one `String` per line, stripping the newline character. Use with `while let Some(line) = lines.next_line().await?`.

### `split(byte)`

Returns a `Split` stream that yields `Vec<u8>` segments separated by the specified byte.

---

## Helper Functions

### `io::copy(reader, writer)`

Copies all bytes from `reader` to `writer` until end-of-stream. Returns the total number of bytes copied. This is the most efficient way to pipe data between two I/O resources.

```rust
use tokio::io;
use tokio::fs::File;

let mut src = File::open("input.txt").await?;
let mut dst = File::create("output.txt").await?;
let bytes_copied = io::copy(&mut src, &mut dst).await?;
println!("Copied {} bytes", bytes_copied);
```

### `io::copy_bidirectional(a, b)`

Copies data in both directions between two bidirectional streams simultaneously. Returns `(a_to_b, b_to_a)` byte counts. Commonly used for TCP proxies.

```rust
use tokio::io;
use tokio::net::TcpStream;

let mut client = TcpStream::connect("127.0.0.1:8080").await?;
let mut upstream = TcpStream::connect("upstream.example.com:80").await?;
let (client_to_upstream, upstream_to_client) =
    io::copy_bidirectional(&mut client, &mut upstream).await?;
```

### `io::split(io)`

Splits a single I/O resource that implements both `AsyncRead + AsyncWrite` into separate `ReadHalf` and `WriteHalf` handles. Both halves can be used concurrently — one task reads while another writes.

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080").await?;
let (mut reader, mut writer) = io::split(stream);

tokio::spawn(async move {
    let mut buf = vec![0u8; 1024];
    loop {
        let n = reader.read(&mut buf).await.unwrap();
        if n == 0 { break; }
        println!("Read {} bytes", n);
    }
});

writer.write_all(b"Hello, server!").await?;
```

### `io::join(read, write)`

The inverse of `split` — combines a separate reader and writer into a single `AsyncRead + AsyncWrite` resource.

### `io::duplex(max_buf_size)`

Creates a pair of connected in-memory streams, like a bidirectional pipe. Writing to one side makes data available for reading on the other. The `max_buf_size` controls backpressure — writes block when the buffer is full.

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};

let (mut client, mut server) = io::duplex(64);

tokio::spawn(async move {
    server.write_all(b"Hello from server").await.unwrap();
});

let mut buf = vec![0u8; 64];
let n = client.read(&mut buf).await.unwrap();
assert_eq!(&buf[..n], b"Hello from server");
```

### `io::empty()`

Returns a reader that always returns end-of-stream (0 bytes read). Useful as a placeholder or in tests.

### `io::sink()`

Returns a writer that discards all data written to it. Useful for benchmarking or discarding output.

### `io::repeat(byte)`

Returns a reader that yields the specified byte infinitely. Use with `take()` to generate a fixed amount of data.

---

## Buffered I/O

### `BufReader`

Wraps an `AsyncRead` with an internal buffer. Reduces the number of syscalls by reading larger chunks from the underlying reader. Implements `AsyncBufRead`, enabling line-based and delimiter-based reading.

```rust
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio::fs::File;

let file = File::open("data.txt").await?;
let reader = BufReader::new(file);
let mut lines = reader.lines();

while let Some(line) = lines.next_line().await? {
    println!("{}", line);
}
```

### `BufWriter`

Wraps an `AsyncWrite` with an internal buffer. Reduces the number of syscalls by batching small writes. Data is flushed when the buffer is full or when `flush()` is called explicitly.

```rust
use tokio::io::{AsyncWriteExt, BufWriter};
use tokio::fs::File;

let file = File::create("output.txt").await?;
let mut writer = BufWriter::new(file);

for i in 0..1000 {
    writer.write_all(format!("line {}\n", i).as_bytes()).await?;
}
writer.flush().await?;
```

### `BufStream`

Combines `BufReader` and `BufWriter` into a single wrapper for bidirectional streams. Useful for protocols that both read and write over the same connection.

---

## ReadHalf and WriteHalf

`io::split()` returns a `ReadHalf<T>` and `WriteHalf<T>`. These hold a shared reference (via `Arc<Mutex>`) to the underlying resource. They can be used independently and concurrently in separate tasks.

For `TcpStream`, prefer `TcpStream::into_split()` which avoids the mutex overhead by consuming the stream.

---

## DuplexStream

A pair of connected in-memory streams created by `io::duplex()`. Implements both `AsyncRead` and `AsyncWrite`. Useful for testing code that works with I/O traits without needing real network connections.

---

## Stdin, Stdout, Stderr

Tokio provides async wrappers around standard I/O handles:

```rust
use tokio::io::{self, AsyncBufReadExt, AsyncWriteExt, BufReader};

let stdin = io::stdin();
let mut stdout = io::stdout();
let reader = BufReader::new(stdin);
let mut lines = reader.lines();

while let Some(line) = lines.next_line().await? {
    stdout.write_all(format!("Echo: {}\n", line).as_bytes()).await?;
    stdout.flush().await?;
}
```

These internally use `spawn_blocking` because standard I/O on most platforms is blocking.

---

## ReadBuf

`ReadBuf` is a wrapper around `&mut [u8]` used by `AsyncRead::poll_read`. It tracks three regions of the buffer:

1. **Filled** — bytes that have been read and initialized.
2. **Initialized but unfilled** — bytes that are initialized (safe to read) but not yet filled with data.
3. **Uninitialized** — bytes that have not been initialized.

This design allows zero-copy reads without requiring the caller to pre-initialize the entire buffer. Most users never interact with `ReadBuf` directly — the `AsyncReadExt` methods handle it.

---

## Examples

### Reading a File Completely

```rust
use tokio::fs::File;
use tokio::io::AsyncReadExt;

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let mut file = File::open("Cargo.toml").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    println!("File length: {} bytes", contents.len());
    Ok(())
}
```

### Writing a File

```rust
use tokio::fs::File;
use tokio::io::AsyncWriteExt;

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let mut file = File::create("hello.txt").await?;
    file.write_all(b"Hello, Tokio!\n").await?;
    file.flush().await?;
    Ok(())
}
```

### Copying Between Streams

```rust
use tokio::io;
use tokio::net::{TcpListener, TcpStream};

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;

    loop {
        let (mut socket, addr) = listener.accept().await?;
        println!("Connection from {}", addr);

        tokio::spawn(async move {
            let (mut reader, mut writer) = socket.split();
            // Echo: copy everything read back to the writer
            match io::copy(&mut reader, &mut writer).await {
                Ok(bytes) => println!("Echoed {} bytes", bytes),
                Err(e) => eprintln!("Error: {}", e),
            }
        });
    }
}
```

### Splitting a Stream for Concurrent Read/Write

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let stream = TcpStream::connect("127.0.0.1:8080").await?;
    let (mut reader, mut writer) = io::split(stream);

    let read_task = tokio::spawn(async move {
        let mut buf = vec![0u8; 4096];
        loop {
            let n = reader.read(&mut buf).await?;
            if n == 0 { break; }
            println!("Received: {}", String::from_utf8_lossy(&buf[..n]));
        }
        Ok::<_, io::Error>(())
    });

    let write_task = tokio::spawn(async move {
        for i in 0..5 {
            writer.write_all(format!("Message {}\n", i).as_bytes()).await?;
            tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        }
        writer.shutdown().await?;
        Ok::<_, io::Error>(())
    });

    let (r1, r2) = tokio::join!(read_task, write_task);
    r1??;
    r2??;
    Ok(())
}
```

### Using DuplexStream for Testing

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt, DuplexStream};

async fn process(stream: &mut DuplexStream) -> io::Result<()> {
    let mut buf = vec![0u8; 1024];
    let n = stream.read(&mut buf).await?;
    let input = String::from_utf8_lossy(&buf[..n]);
    let response = format!("Processed: {}", input);
    stream.write_all(response.as_bytes()).await?;
    Ok(())
}

#[tokio::test]
async fn test_process() {
    let (mut client, mut server) = io::duplex(1024);

    let server_task = tokio::spawn(async move {
        process(&mut server).await.unwrap();
    });

    client.write_all(b"hello").await.unwrap();

    let mut buf = vec![0u8; 1024];
    let n = client.read(&mut buf).await.unwrap();
    assert_eq!(&buf[..n], b"Processed: hello");

    server_task.await.unwrap();
}
```

### Reading Binary Protocol Data

```rust
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;

async fn read_frame(stream: &mut TcpStream) -> std::io::Result<Vec<u8>> {
    // Read a 4-byte big-endian length prefix
    let len = stream.read_u32().await? as usize;

    // Read exactly that many bytes
    let mut payload = vec![0u8; len];
    stream.read_exact(&mut payload).await?;

    Ok(payload)
}

async fn write_frame(stream: &mut TcpStream, data: &[u8]) -> std::io::Result<()> {
    stream.write_u32(data.len() as u32).await?;
    stream.write_all(data).await?;
    stream.flush().await?;
    Ok(())
}
```

---

## Thread Safety

| Type | `Send` | `Sync` | `Clone` | Notes |
|------|--------|--------|---------|-------|
| `BufReader<R>` | if R: Send | if R: Sync | No | Wraps reader with buffer |
| `BufWriter<W>` | if W: Send | if W: Sync | No | Wraps writer with buffer |
| `ReadHalf<T>` | Yes | Yes | No | Shared via Arc internally |
| `WriteHalf<T>` | Yes | Yes | No | Shared via Arc internally |
| `DuplexStream` | Yes | Yes | No | In-memory bidirectional pipe |
| `Empty` | Yes | Yes | Yes | Zero-length reader |
| `Sink` | Yes | Yes | Yes | Discards all writes |
| `Repeat` | Yes | Yes | Yes | Infinite single-byte reader |

---

## See Also

- [The Tokio Runtime](01-runtime.md) — the I/O driver must be enabled via `enable_io()` or `enable_all()`
- [Tasks and Spawning](02-tasks.md) — spawning tasks that perform I/O
- [TCP, UDP, and Unix Sockets](04-networking.md) — networking types that implement these I/O traits
