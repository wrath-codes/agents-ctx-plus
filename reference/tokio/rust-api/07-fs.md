# Async File System

The `tokio::fs` module provides async versions of standard file system operations. Internally, these operations dispatch to a blocking thread pool via `spawn_blocking`, so they are not truly non-blocking at the OS level — but they avoid blocking the async runtime's worker threads.

For high-throughput file I/O, consider dedicated I/O runtimes or memory-mapped files. For typical application file operations (config loading, log writing, file management), `tokio::fs` is the correct choice.

---

## File

### API Reference

```rust
pub struct File { /* ... */ }

impl File {
    pub async fn open(path: impl AsRef<Path>) -> io::Result<File>
    pub async fn create(path: impl AsRef<Path>) -> io::Result<File>
    pub async fn create_new(path: impl AsRef<Path>) -> io::Result<File>
    pub fn from_std(std: std::fs::File) -> File
    pub fn into_std(self) -> std::fs::File
    pub async fn sync_all(&self) -> io::Result<()>
    pub async fn sync_data(&self) -> io::Result<()>
    pub async fn set_len(&self, size: u64) -> io::Result<()>
    pub async fn metadata(&self) -> io::Result<Metadata>
    pub async fn try_clone(&self) -> io::Result<File>
    pub async fn set_permissions(&self, perm: Permissions) -> io::Result<()>
    pub fn try_into_std(self) -> Result<std::fs::File, File>
}

impl AsyncRead for File { /* ... */ }
impl AsyncWrite for File { /* ... */ }
impl AsyncSeek for File { /* ... */ }
```

`File` implements `AsyncRead`, `AsyncWrite`, and `AsyncSeek`, so it works with `tokio::io::AsyncReadExt` and `tokio::io::AsyncWriteExt` methods.

### Opening and Reading

```rust
use tokio::fs::File;
use tokio::io::AsyncReadExt;

let mut file = File::open("config.toml").await?;
let mut contents = String::new();
file.read_to_string(&mut contents).await?;
println!("{}", contents);
```

### Creating and Writing

```rust
use tokio::fs::File;
use tokio::io::AsyncWriteExt;

let mut file = File::create("output.txt").await?;
file.write_all(b"hello world\n").await?;
file.flush().await?;
```

### Converting from std::fs::File

```rust
use tokio::fs::File;

let std_file = std::fs::File::open("data.bin")?;
let tokio_file = File::from_std(std_file);
```

---

## OpenOptions

### API Reference

```rust
pub struct OpenOptions { /* ... */ }

impl OpenOptions {
    pub fn new() -> Self
    pub fn read(&mut self, read: bool) -> &mut Self
    pub fn write(&mut self, write: bool) -> &mut Self
    pub fn append(&mut self, append: bool) -> &mut Self
    pub fn truncate(&mut self, truncate: bool) -> &mut Self
    pub fn create(&mut self, create: bool) -> &mut Self
    pub fn create_new(&mut self, create_new: bool) -> &mut Self
    pub async fn open(&self, path: impl AsRef<Path>) -> io::Result<File>
    pub fn mode(&mut self, mode: u32) -> &mut Self       // Unix only
    pub fn custom_flags(&mut self, flags: i32) -> &mut Self // Unix only
}
```

### Usage

Fine-grained control over file open behavior. Mirrors `std::fs::OpenOptions`.

```rust
use tokio::fs::OpenOptions;
use tokio::io::AsyncWriteExt;

let mut file = OpenOptions::new()
    .append(true)
    .create(true)
    .open("app.log")
    .await?;

file.write_all(b"log entry\n").await?;
```

### Read-Write Mode

```rust
use tokio::fs::OpenOptions;

let file = OpenOptions::new()
    .read(true)
    .write(true)
    .create(true)
    .truncate(true)
    .open("data.bin")
    .await?;
```

---

## Convenience Functions

### Reading

```rust
pub async fn read(path: impl AsRef<Path>) -> io::Result<Vec<u8>>
pub async fn read_to_string(path: impl AsRef<Path>) -> io::Result<String>
```

```rust
use tokio::fs;

let bytes = fs::read("image.png").await?;
let text = fs::read_to_string("config.toml").await?;
```

### Writing

```rust
pub async fn write(path: impl AsRef<Path>, contents: impl AsRef<[u8]>) -> io::Result<()>
```

```rust
use tokio::fs;

fs::write("output.txt", b"hello world").await?;
fs::write("config.json", serde_json::to_string_pretty(&config)?).await?;
```

---

## Directory Operations

```rust
pub async fn create_dir(path: impl AsRef<Path>) -> io::Result<()>
pub async fn create_dir_all(path: impl AsRef<Path>) -> io::Result<()>
pub async fn remove_dir(path: impl AsRef<Path>) -> io::Result<()>
pub async fn remove_dir_all(path: impl AsRef<Path>) -> io::Result<()>
pub async fn read_dir(path: impl AsRef<Path>) -> io::Result<ReadDir>
```

### Reading Directory Entries

```rust
use tokio::fs;

let mut entries = fs::read_dir(".").await?;
while let Some(entry) = entries.next_entry().await? {
    let name = entry.file_name();
    let metadata = entry.metadata().await?;
    println!("{:?} ({})", name, if metadata.is_dir() { "dir" } else { "file" });
}
```

### ReadDir and DirEntry

```rust
pub struct ReadDir { /* ... */ }

impl ReadDir {
    pub async fn next_entry(&mut self) -> io::Result<Option<DirEntry>>
}

pub struct DirEntry { /* ... */ }

impl DirEntry {
    pub fn path(&self) -> PathBuf
    pub fn file_name(&self) -> OsString
    pub async fn metadata(&self) -> io::Result<Metadata>
    pub async fn file_type(&self) -> io::Result<FileType>
    pub fn ino(&self) -> u64  // Unix only
}
```

### Creating Nested Directories

```rust
use tokio::fs;

fs::create_dir_all("data/cache/thumbnails").await?;
```

---

## DirBuilder

```rust
pub struct DirBuilder { /* ... */ }

impl DirBuilder {
    pub fn new() -> Self
    pub fn recursive(&mut self, recursive: bool) -> &mut Self
    pub fn mode(&mut self, mode: u32) -> &mut Self  // Unix only
    pub async fn create(&self, path: impl AsRef<Path>) -> io::Result<()>
}
```

```rust
use tokio::fs::DirBuilder;

DirBuilder::new()
    .recursive(true)
    .create("data/output/reports")
    .await?;
```

---

## File Operations

```rust
pub async fn copy(from: impl AsRef<Path>, to: impl AsRef<Path>) -> io::Result<u64>
pub async fn rename(from: impl AsRef<Path>, to: impl AsRef<Path>) -> io::Result<()>
pub async fn remove_file(path: impl AsRef<Path>) -> io::Result<()>
pub async fn metadata(path: impl AsRef<Path>) -> io::Result<Metadata>
pub async fn symlink_metadata(path: impl AsRef<Path>) -> io::Result<Metadata>
```

```rust
use tokio::fs;

let bytes_copied = fs::copy("source.txt", "backup.txt").await?;
println!("copied {} bytes", bytes_copied);

fs::rename("old_name.txt", "new_name.txt").await?;
fs::remove_file("temp.txt").await?;

let meta = fs::metadata("file.txt").await?;
println!("size: {} bytes, modified: {:?}", meta.len(), meta.modified()?);
```

---

## Link Operations

```rust
pub async fn hard_link(src: impl AsRef<Path>, dst: impl AsRef<Path>) -> io::Result<()>
pub async fn read_link(path: impl AsRef<Path>) -> io::Result<PathBuf>

// Unix only
pub async fn symlink(src: impl AsRef<Path>, dst: impl AsRef<Path>) -> io::Result<()>
```

```rust
use tokio::fs;

fs::hard_link("original.txt", "hardlink.txt").await?;

#[cfg(unix)]
fs::symlink("target_dir", "link_dir").await?;

let target = fs::read_link("link_dir").await?;
println!("link points to: {:?}", target);
```

---

## Path Operations

```rust
pub async fn canonicalize(path: impl AsRef<Path>) -> io::Result<PathBuf>
pub async fn try_exists(path: impl AsRef<Path>) -> io::Result<bool>
pub async fn set_permissions(path: impl AsRef<Path>, perm: Permissions) -> io::Result<()>
```

```rust
use tokio::fs;

let absolute = fs::canonicalize("../relative/path").await?;
println!("absolute path: {:?}", absolute);

if fs::try_exists("config.toml").await? {
    println!("config exists");
}
```

---

## Examples

### Recursively Process Files

```rust
use tokio::fs;
use std::path::Path;

async fn process_directory(dir: &Path) -> io::Result<()> {
    let mut entries = fs::read_dir(dir).await?;
    while let Some(entry) = entries.next_entry().await? {
        let path = entry.path();
        if path.is_dir() {
            Box::pin(process_directory(&path)).await?;
        } else if path.extension().map_or(false, |ext| ext == "txt") {
            let contents = fs::read_to_string(&path).await?;
            println!("{}: {} bytes", path.display(), contents.len());
        }
    }
    Ok(())
}
```

### Atomic File Write

```rust
use tokio::fs;
use std::path::Path;

async fn atomic_write(path: &Path, contents: &[u8]) -> io::Result<()> {
    let tmp_path = path.with_extension("tmp");
    fs::write(&tmp_path, contents).await?;
    fs::rename(&tmp_path, path).await?;
    Ok(())
}
```

### Streaming File Copy with Progress

```rust
use tokio::fs::File;
use tokio::io::{AsyncReadExt, AsyncWriteExt, BufReader, BufWriter};

async fn copy_with_progress(src: &str, dst: &str) -> io::Result<u64> {
    let src_file = File::open(src).await?;
    let dst_file = File::create(dst).await?;

    let file_size = src_file.metadata().await?.len();
    let mut reader = BufReader::new(src_file);
    let mut writer = BufWriter::new(dst_file);

    let mut total = 0u64;
    let mut buf = vec![0u8; 8192];

    loop {
        let n = reader.read(&mut buf).await?;
        if n == 0 {
            break;
        }
        writer.write_all(&buf[..n]).await?;
        total += n as u64;

        let pct = (total as f64 / file_size as f64 * 100.0) as u32;
        println!("{}% ({}/{})", pct, total, file_size);
    }

    writer.flush().await?;
    Ok(total)
}
```

---

## Implementation Note

All `tokio::fs` operations internally call `spawn_blocking` to run the corresponding `std::fs` operation on Tokio's blocking thread pool. This means:

- They will not block async worker threads.
- They have slightly higher overhead than direct `std::fs` calls due to thread pool scheduling.
- They are subject to the blocking thread pool's concurrency limits (`max_blocking_threads`).
- For CPU-bound processing of file contents, consider reading the file with `tokio::fs` then processing with `spawn_blocking`.

---

## See Also

- [Synchronization Primitives](06-sync.md) — channels and locks for coordinating file access
- [Time Utilities](05-time.md) — timeouts for file operations
- [Macros](08-macros.md) — `select!` for cancellable file operations
