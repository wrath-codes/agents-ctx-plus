# Parser

The `Parser` struct is the entry point for parsing source code with tree-sitter. It holds a reference to a language grammar and produces concrete syntax trees (`Tree`) from source text.

`Parser` is `Send` but **not** `Sync` — it may be moved between threads but must not be shared concurrently. Trees returned by the parser can be cheaply cloned (atomic reference count) and sent to other threads.

---

## API Reference

```rust
impl Parser {
    pub fn new() -> Self
    pub fn set_language(&mut self, language: &Language) -> Result<(), LanguageError>
    pub fn language(&self) -> Option<LanguageRef<'_>>
    pub fn parse(&mut self, text: impl AsRef<[u8]>, old_tree: Option<&Tree>) -> Option<Tree>
    pub fn parse_with_options<T: AsRef<[u8]>, F: FnMut(usize, Point) -> T>(
        &mut self,
        callback: &mut F,
        old_tree: Option<&Tree>,
        options: Option<ParseOptions>,
    ) -> Option<Tree>
    pub fn reset(&mut self)
    pub fn set_included_ranges(&mut self, ranges: &[Range]) -> Result<(), IncludedRangesError>
    pub fn included_ranges(&self) -> Vec<Range>
    pub fn set_logger(&mut self, logger: Option<Logger>)
}
```

### `Parser::new()`

Creates a new parser with no language assigned. You must call `set_language` before parsing.

### `Parser::set_language(&mut self, language: &Language) -> Result<(), LanguageError>`

Assigns a language grammar to the parser. Returns `Err(LanguageError::Version(_))` if the grammar was generated by an incompatible version of tree-sitter.

### `Parser::language(&self) -> Option<LanguageRef<'_>>`

Returns the currently assigned language, or `None` if no language has been set.

### `Parser::parse(&mut self, text: impl AsRef<[u8]>, old_tree: Option<&Tree>) -> Option<Tree>`

Parses the entire `text` buffer and returns a `Tree`. Pass `old_tree` from a previous parse for incremental re-parsing after edits. Returns `None` if no language is set or if parsing was cancelled.

### `Parser::parse_with_options()`

Parses source code supplied through a callback function rather than a contiguous buffer. The callback receives `(byte_offset, position)` and must return a chunk of source bytes starting at that offset. Return an empty slice to signal end-of-input. This is essential for data structures that don't store text contiguously (ropes, piece tables, gap buffers).

### `Parser::reset(&mut self)`

Resets the parser's internal state. Call this if you want to parse a completely unrelated document without reusing any state from a previous parse.

### `Parser::set_included_ranges(&mut self, ranges: &[Range]) -> Result<(), IncludedRangesError>`

Restricts the parser to only consider the given byte ranges within the source. Ranges must be non-overlapping, sorted, and non-empty. This enables parsing of embedded languages in multi-language documents (e.g., JavaScript inside HTML `<script>` tags).

### `Parser::included_ranges(&self) -> Vec<Range>`

Returns the ranges currently set, or a single range covering the entire document if none were set.

### `Parser::set_logger(&mut self, logger: Option<Logger>)`

Sets a debug logger. The logger callback receives `LogType` (Parse or Lex) and a message string. Useful for diagnosing grammar issues. Pass `None` to disable logging.

---

## Examples

### Basic Parsing from a String

```rust
use tree_sitter::Parser;

let mut parser = Parser::new();
let language = tree_sitter_rust::LANGUAGE;
parser
    .set_language(&language.into())
    .expect("Error loading Rust grammar");

let source = "fn main() {}";
let tree = parser.parse(source, None).unwrap();
let root = tree.root_node();

assert_eq!(root.kind(), "source_file");
assert_eq!(root.child_count(), 1);
assert_eq!(root.child(0).unwrap().kind(), "function_item");
```

### Parsing with a Callback (Rope / Piece Table)

When source text is stored in a non-contiguous data structure, supply a callback instead of a flat buffer. The parser calls the callback repeatedly, requesting chunks by byte offset and position.

```rust
use tree_sitter::{Parser, Point};

// Simulated rope: each chunk is a separate string.
let chunks: Vec<&str> = vec!["fn ", "main()", " {", "}"];
let full_source: String = chunks.concat();

let mut parser = Parser::new();
parser
    .set_language(&tree_sitter_rust::LANGUAGE.into())
    .unwrap();

let mut callback = |byte_offset: usize, _position: Point| -> &[u8] {
    if byte_offset >= full_source.len() {
        return b"";
    }
    &full_source.as_bytes()[byte_offset..]
};

let tree = parser
    .parse_with_options(&mut callback, None, None)
    .unwrap();

assert_eq!(tree.root_node().kind(), "source_file");
```

In production, the callback would index into your rope or piece table to return the chunk starting at `byte_offset` without copying the entire document.

### Incremental Re-parsing with `old_tree`

After an edit, inform the old tree about the change with `tree.edit()`, then pass it to `parser.parse()`. The parser reuses unchanged subtrees, making the re-parse proportional to the size of the change rather than the document.

```rust
use tree_sitter::{InputEdit, Parser, Point};

let mut parser = Parser::new();
parser
    .set_language(&tree_sitter_rust::LANGUAGE.into())
    .unwrap();

let source_v1 = b"fn main() {}";
let mut tree = parser.parse(source_v1, None).unwrap();

// User inserts " return;" inside the braces at byte offset 11.
// "fn main() {}" -> "fn main() { return; }"
let source_v2 = b"fn main() { return; }";

tree.edit(&InputEdit {
    start_byte: 11,
    old_end_byte: 11,
    new_end_byte: 20,
    start_position: Point { row: 0, column: 11 },
    old_end_position: Point { row: 0, column: 11 },
    new_end_position: Point { row: 0, column: 20 },
});

let new_tree = parser.parse(source_v2, Some(&tree)).unwrap();
let root = new_tree.root_node();
assert_eq!(root.kind(), "source_file");

// Inspect changed ranges between the two trees.
let changes: Vec<_> = tree.changed_ranges(&new_tree).collect();
assert!(!changes.is_empty());
```

### Setting Included Ranges for Multi-Language Documents

Parse only specific regions of a document — for example, extracting Rust code from within Markdown fenced code blocks.

```rust
use tree_sitter::{Parser, Point, Range};

let source = b"# Heading\n```rust\nfn foo() {}\n```\nMore text";

// The Rust code block spans bytes 18..30 (the "fn foo() {}\n" portion).
let rust_start = 18;
let rust_end = 30;

let mut parser = Parser::new();
parser
    .set_language(&tree_sitter_rust::LANGUAGE.into())
    .unwrap();

parser
    .set_included_ranges(&[Range {
        start_byte: rust_start,
        end_byte: rust_end,
        start_point: Point { row: 2, column: 0 },
        end_point: Point { row: 3, column: 0 },
    }])
    .unwrap();

let tree = parser.parse(source, None).unwrap();
let root = tree.root_node();
assert_eq!(root.kind(), "source_file");
assert_eq!(root.named_child(0).unwrap().kind(), "function_item");
```

### Setting a Logger for Debugging

Attach a logger to observe the parser's internal lex and parse actions. This is invaluable when debugging grammar issues.

```rust
use tree_sitter::Parser;

let mut parser = Parser::new();
parser
    .set_language(&tree_sitter_rust::LANGUAGE.into())
    .unwrap();

parser.set_logger(Some(Box::new(|log_type, message| {
    eprintln!("[{:?}] {}", log_type, message);
})));

let _tree = parser.parse("fn main() {}", None).unwrap();

// Disable logging when done.
parser.set_logger(None);
```

---

## Thread Safety

| Property | Value |
|----------|-------|
| `Send`   | Yes   |
| `Sync`   | No    |

A `Parser` can be moved to another thread, but it must not be used concurrently from multiple threads. If you need to parse on multiple threads, create one `Parser` per thread.

`Tree` values returned by the parser implement `Clone` with cheap atomic reference counting. Clone a tree and send the clone to another thread for concurrent read access.

---

## See Also

- [Trees and Nodes](02-tree-and-nodes.md) — working with the syntax tree produced by the parser
- [TreeCursor](03-tree-cursor.md) — efficient tree traversal
- [Queries](04-queries.md) — pattern matching on syntax trees
- [Supporting Types](05-types.md) — `Point`, `Range`, `InputEdit`, `Language`, error types
