# Supporting Types

This document covers all supporting types in the `tree_sitter` crate: position types, edit descriptions, language handles, error types, query predicates, and logging.

---

## Position Types

### Point

A zero-based row/column position in the source text.

```rust
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]
pub struct Point {
    pub row: usize,
    pub column: usize,
}
```

- `row` — zero-based line number.
- `column` — zero-based **byte** offset within the line (not character offset). For ASCII text, bytes and characters are the same. For multi-byte UTF-8, `column` counts bytes.

```rust
use tree_sitter::Point;

let origin = Point { row: 0, column: 0 };
let p = Point { row: 5, column: 12 };
assert_eq!(Point::default(), origin);
```

### Range

A byte + point span in the source text. Used for node positions, included ranges, and changed ranges.

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct Range {
    pub start_byte: usize,
    pub end_byte: usize,
    pub start_point: Point,
    pub end_point: Point,
}
```

```rust
use tree_sitter::{Point, Range};

let range = Range {
    start_byte: 0,
    end_byte: 12,
    start_point: Point { row: 0, column: 0 },
    end_point: Point { row: 0, column: 12 },
};
```

> **Note:** `tree_sitter::Range` is distinct from `std::ops::Range<usize>`. Node methods like `byte_range()` return `std::ops::Range<usize>`, while `range()` returns `tree_sitter::Range`.

---

## InputEdit

Describes a text edit for incremental parsing. All byte offsets and positions refer to the state of the document **before** the edit is applied.

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct InputEdit {
    pub start_byte: usize,
    pub old_end_byte: usize,
    pub new_end_byte: usize,
    pub start_position: Point,
    pub old_end_position: Point,
    pub new_end_position: Point,
}
```

| Field | Meaning |
|-------|---------|
| `start_byte` | Byte offset where the edit begins |
| `old_end_byte` | Byte offset where the old (deleted) text ended |
| `new_end_byte` | Byte offset where the new (inserted) text ends |
| `start_position` | Point where the edit begins |
| `old_end_position` | Point where the old text ended |
| `new_end_position` | Point where the new text ends |

### Common Edit Patterns

**Insertion** at byte offset 10 of 5 bytes:
```rust
use tree_sitter::{InputEdit, Point};

let edit = InputEdit {
    start_byte: 10,
    old_end_byte: 10,        // no text removed
    new_end_byte: 15,        // 5 bytes inserted
    start_position: Point { row: 0, column: 10 },
    old_end_position: Point { row: 0, column: 10 },
    new_end_position: Point { row: 0, column: 15 },
};
```

**Deletion** of bytes 10..15:
```rust
use tree_sitter::{InputEdit, Point};

let edit = InputEdit {
    start_byte: 10,
    old_end_byte: 15,        // 5 bytes removed
    new_end_byte: 10,        // nothing inserted
    start_position: Point { row: 0, column: 10 },
    old_end_position: Point { row: 0, column: 15 },
    new_end_position: Point { row: 0, column: 10 },
};
```

**Replacement** of bytes 10..15 with 8 bytes:
```rust
use tree_sitter::{InputEdit, Point};

let edit = InputEdit {
    start_byte: 10,
    old_end_byte: 15,        // 5 bytes removed
    new_end_byte: 18,        // 8 bytes inserted (10 + 8)
    start_position: Point { row: 0, column: 10 },
    old_end_position: Point { row: 0, column: 15 },
    new_end_position: Point { row: 0, column: 18 },
};
```

---

## Language Types

### Language

Opaque handle to a tree-sitter grammar. Language grammars are typically provided by separate crates (e.g., `tree_sitter_rust`, `tree_sitter_javascript`). Convert a grammar's language constant to `Language` with `.into()`.

```rust
pub struct Language { /* opaque */ }
```

```rust
let language: tree_sitter::Language = tree_sitter_rust::LANGUAGE.into();
```

### LanguageRef

A borrowed reference to a `Language`, returned by `Parser::language()` and `Tree::language()`.

```rust
pub struct LanguageRef<'a> { /* opaque */ }
```

### LanguageError

Returned by `Parser::set_language()` when the grammar was generated by an incompatible tree-sitter version.

```rust
pub enum LanguageError {
    Version(usize),
}
```

```rust
use tree_sitter::Parser;

let mut parser = Parser::new();
match parser.set_language(&tree_sitter_rust::LANGUAGE.into()) {
    Ok(()) => println!("Language loaded"),
    Err(tree_sitter::LanguageError::Version(v)) => {
        eprintln!("Incompatible grammar version: {}", v);
    }
}
```

---

## Query Error Types

### QueryError

Returned by `Query::new()` when the pattern string is invalid.

```rust
pub struct QueryError {
    pub row: usize,
    pub column: usize,
    pub offset: usize,
    pub message: String,
    pub kind: QueryErrorKind,
}
```

### QueryErrorKind

```rust
pub enum QueryErrorKind {
    Syntax,
    NodeType,
    Field,
    Capture,
    Structure,
    Language,
}
```

| Variant | Meaning |
|---------|---------|
| `Syntax` | Malformed pattern syntax |
| `NodeType` | Unknown node type name |
| `Field` | Unknown field name |
| `Capture` | Invalid capture reference |
| `Structure` | Structurally invalid pattern |
| `Language` | Language mismatch or incompatibility |

```rust
use tree_sitter::Query;

let result = Query::new(
    &tree_sitter_rust::LANGUAGE.into(),
    "(nonexistent_node_type) @cap",
);

if let Err(e) = result {
    eprintln!(
        "Query error at {}:{} (offset {}): {} [{:?}]",
        e.row, e.column, e.offset, e.message, e.kind,
    );
}
```

---

## Query Predicate Types

Tree-sitter queries can contain predicates like `#eq?` and `#match?`. The tree-sitter library parses these but may not evaluate all of them — your code must handle general predicates.

### QueryPredicate

```rust
pub struct QueryPredicate {
    pub operator: Box<str>,
    pub args: Vec<QueryPredicateArg>,
}
```

### QueryPredicateArg

```rust
pub enum QueryPredicateArg {
    Capture(u32),
    String(Box<str>),
}
```

### QueryProperty

```rust
pub struct QueryProperty {
    pub key: Box<str>,
    pub value: Option<Box<str>>,
    pub capture_id: Option<usize>,
}
```

### CaptureQuantifier

```rust
pub enum CaptureQuantifier {
    Zero,
    ZeroOrOne,
    ZeroOrMore,
    One,
    OneOrMore,
}
```

---

## Logging

### LogType

```rust
pub enum LogType {
    Parse,
    Lex,
}
```

### Logger

The logger is a boxed closure:

```rust
pub type Logger<'a> = Box<dyn FnMut(LogType, &str) + 'a>;
```

```rust
use tree_sitter::{LogType, Parser};

let mut parser = Parser::new();
parser
    .set_language(&tree_sitter_rust::LANGUAGE.into())
    .unwrap();

parser.set_logger(Some(Box::new(|log_type: LogType, msg: &str| {
    match log_type {
        LogType::Parse => eprintln!("[PARSE] {}", msg),
        LogType::Lex => eprintln!("[LEX]   {}", msg),
    }
})));

let _tree = parser.parse("let x = 1;", None);
parser.set_logger(None);
```

---

## C-to-Rust Type Mapping

| C Type | Rust Type |
|--------|-----------|
| `TSLanguage` | `Language` |
| `TSParser` | `Parser` |
| `TSTree` | `Tree` |
| `TSNode` | `Node<'tree>` |
| `TSTreeCursor` | `TreeCursor<'tree>` |
| `TSQuery` | `Query` |
| `TSQueryCursor` | `QueryCursor` |
| `TSQueryMatch` | `QueryMatch<'cursor, 'tree>` |
| `TSQueryCapture` | `QueryCapture<'tree>` |
| `TSPoint` | `Point` |
| `TSRange` | `Range` |
| `TSInputEdit` | `InputEdit` |

---

## Thread Safety Summary

| Type | Send | Sync | Notes |
|------|------|------|-------|
| `Parser` | Yes | No | Stateful, one thread at a time |
| `Tree` | Yes | No | Clone is cheap (atomic refcount), use copies across threads |
| `Node<'tree>` | Yes | Yes | Immutable view into tree |
| `Query` | Yes | Yes | Immutable after creation |
| `QueryCursor` | Yes | No | Stateful cursor |
| `TreeCursor<'tree>` | Yes | No | Stateful cursor |
| `Language` | Yes | Yes | Immutable |

---

## See Also

- [Parser](01-parser.md) — uses `Language`, `LanguageError`, `Range`, `Logger`
- [Trees and Nodes](02-tree-and-nodes.md) — uses `Point`, `Range`, `InputEdit`
- [TreeCursor](03-tree-cursor.md) — uses `Point`, `FieldId`
- [Queries](04-queries.md) — uses `QueryError`, `QueryPredicate`, `QueryProperty`
