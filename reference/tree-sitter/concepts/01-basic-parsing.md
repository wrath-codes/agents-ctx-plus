# Basic Parsing

Tree-sitter's parsing model revolves around four core objects: **Language**, **Parser**, **Tree**, and **Node**.

---

## The Four Core Objects

### Language

An opaque object that defines how to parse a particular programming language. Languages are generated by the `tree-sitter` CLI from a `grammar.js` file and distributed as separate crates. In Rust, you obtain a language reference from the language crate:

```rust
// From the tree-sitter-rust crate
let language = tree_sitter_rust::LANGUAGE;
```

You never construct a `Language` yourself â€” it is always provided by a generated grammar crate.

### Parser

A stateful object that is assigned a `Language` and produces `Tree`s from source code. A single parser can be reused across multiple parse calls.

```rust
let mut parser = Parser::new();
parser.set_language(&tree_sitter_rust::LANGUAGE.into()).unwrap();
```

### Tree

Represents the complete syntax tree of an entire source file. A `Tree` is immutable after creation (except for editing metadata for incremental re-parsing). It contains `Node`s and can be walked with cursors.

### Node

A single node in the syntax tree. Each node tracks:

- Its **kind** (grammar rule name, e.g. `"function_item"`)
- Its **byte range** and **row/column positions** in the source
- **Parent**, **child**, and **sibling** relationships
- **Field names** for named children (e.g. `"name"`, `"body"`)

---

## Complete Example

```rust
use tree_sitter::Parser;

let mut parser = Parser::new();
parser.set_language(&tree_sitter_rust::LANGUAGE.into()).unwrap();

let source = "fn add(a: i32, b: i32) -> i32 { a + b }";
let tree = parser.parse(source, None).unwrap();
let root = tree.root_node();

assert_eq!(root.kind(), "source_file");
assert_eq!(root.child_count(), 1);

let func = root.child(0).unwrap();
assert_eq!(func.kind(), "function_item");

let name = func.child_by_field_name("name").unwrap();
assert_eq!(name.utf8_text(source.as_bytes()).unwrap(), "add");
```

---

## Providing Source Code

`Parser::parse()` accepts `impl AsRef<[u8]>`, so both `&str` and `&[u8]` work directly:

```rust
// &str
let tree = parser.parse("fn main() {}", None).unwrap();

// &[u8]
let tree = parser.parse(b"fn main() {}" as &[u8], None).unwrap();
```

For custom data structures like piece tables or ropes that don't store source as a contiguous byte slice, use `parse_with_options` (or `parse_with` in older API versions) with a callback that provides chunks on demand:

```rust
let tree = parser.parse_with(&mut |byte_offset, _position| {
    // Return the chunk of source at byte_offset
    get_chunk_at(byte_offset)
}, None).unwrap();
```
